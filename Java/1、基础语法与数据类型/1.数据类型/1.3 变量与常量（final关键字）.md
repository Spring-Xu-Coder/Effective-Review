### **1. 变量介绍**

#### **(1) 定义**
- 变量是用来存储数据的内存区域，其值可以在程序运行期间改变。
- 每个变量都有一个类型，决定了它可以存储的数据种类。

#### **(2) 声明与初始化**
- **语法：**
  ```java
  <数据类型> <变量名> = <初始值>;
  ```
- **示例：**
  ```java
  int age = 25; // 整型变量
  double salary = 5000.5; // 浮点型变量
  String name = "Alice"; // 字符串变量
  ```

#### **(3) 分类**
- **局部变量：** 定义在方法或代码块中，作用域仅限于该方法或代码块。
- **实例变量：** 定义在类中但不在方法中，属于对象的一部分，每个对象都有自己的一份实例变量。
- **类变量（静态变量）：** 使用 `static` 修饰，属于类本身，所有对象共享同一份类变量。

---

### **2. 常量（final 关键字）介绍**

#### **(1) 定义**
- 常量是使用 `final` 关键字修饰的变量，一旦赋值后就不能再更改。
- 常量通常用于表示固定不变的值，例如数学常数、配置参数等。

#### **(2) 声明与初始化**
- **语法：**
  ```java
  final <数据类型> <常量名> = <初始值>;
  ```
- **示例：**
  ```java
  final double PI = 3.14159; // 数学常量 π
  final int MAX_SIZE = 100; // 最大尺寸限制
  ```

#### **(3) 特点**
- **不可修改：** 一旦赋值后，常量的值不能被改变。
- **命名规范：** 常量名通常使用大写字母，单词之间用下划线分隔（如 `MAX_SIZE`）。
- **编译期常量：** 如果常量是基本数据类型或字符串，并且在声明时直接赋值，则会被编译器优化为编译期常量。

#### **(4) 总结**
- 使用场景总结

| **场景**         | **语义**                                     | **实现原理**                                                                 |
|-------------------|----------------------------------------------|------------------------------------------------------------------------------|
| `final` 类       | 禁止继承                                    | JVM 设置 `ACC_FINAL` 标志位，禁止子类继承。                                 |
| `final` 方法     | 禁止重写                                    | JVM 设置 `ACC_FINAL` 标志位，避免动态绑定，提高调用效率。                    |
| `final` 变量     | 禁止重新赋值                                | 编译期常量会被内联；运行时常量由 JVM 确保只赋值一次。                        |
| 线程安全性       | 确保初始化值对所有线程可见                  | 使用内存屏障防止指令重排序，确保不可变性。                                  |

- 编译期内联概念

| **特性**                  | **描述**                                                                 |
|---------------------------|--------------------------------------------------------------------------|
| **编译期常量条件**         | 必须是 `static final`，并且初始化值是编译期常量表达式。                   |
| **内联机制**               | 编译器将编译期常量的值直接嵌入到使用它的代码中，而不是生成对变量的引用。   |
| **性能优化**               | 消除了运行时对变量的访问开销，提高执行效率。                              |
| **潜在问题**               | 如果常量值发生变化但未重新编译依赖类，可能导致使用旧值的情况。            |

- 线程安全性

| **特性**                  | **描述**                                                                 |
|---------------------------|--------------------------------------------------------------------------|
| **确保可见性**            | `final` 变量的初始化值对所有线程可见，避免因缓存或重排序导致的可见性问题。   |
| **防止指令重排序**        | JVM 在 `final` 变量的初始化过程中插入内存屏障，防止指令重排序。             |
| **不可变性**              | 如果对象的所有字段都是 `final` 并且引用的对象也是不可变的，则该对象是线程安全的。 |
| **局限性**                | `final` 仅保证引用不可变，引用对象的内容仍可修改；复合操作需额外同步。         |

  - **内存屏障** （Memory Barrier 或 Memory Fence）是一种特殊的指令，用于控制处理器和内存之间的交互顺序。它的作用包括：
    - **防止指令重排序**：确保某些操作的顺序不会被编译器、运行时环境或硬件优化所改变。
    - **保证可见性**：确保某个线程写入的值能够被其他线程正确地看到。

- **内存屏障分为两种主要类型：**
    - **Load Barrier**：读屏障，确保在屏障之后的读操作不会被重排序到屏障之前。
    - **Store Barrier**：写屏障，确保在屏障之前的写操作不会被重排序到屏障之后。
---

### **3. 变量与常量的区别**

| 特性              | 变量                          | 常量                          |
|-------------------|-------------------------------|-------------------------------|
| **是否可变**      | 值可以改变                    | 值不可改变                    |
| **关键字**        | 无                            | 使用 `final` 修饰             |
| **命名规范**      | 小驼峰命名法（如 `age`, `name`） | 大写加下划线（如 `MAX_SIZE`） |
| **适用场景**      | 存储动态变化的数据            | 存储固定不变的数据            |

---

### **4. 示例代码**

```java
public class VariableAndConstant {
    public static void main(String[] args) {
        // 变量示例
        int age = 25;
        System.out.println("当前年龄: " + age);
        age = 26; // 修改变量值
        System.out.println("修改后的年龄: " + age);

        // 常量示例
        final double PI = 3.14159;
        System.out.println("圆周率: " + PI);

        // 尝试修改常量会报错
        // PI = 3.14; // 编译错误
    }
}
```

---

### **5. 注意事项**

1. **常量必须初始化：**
   - 如果常量是类变量或实例变量，必须在声明时或构造器中初始化。
   - 示例：
     ```java
     class Example {
         final int NUMBER; // 必须初始化
         Example() {
             NUMBER = 10;
         }
     }
     ```

2. **引用类型的常量：**
   - 对于引用类型的常量（如数组、对象），`final` 修饰的是引用本身，而不是引用指向的对象内容。
   - 示例：
     ```java
     final StringBuilder sb = new StringBuilder("Hello");
     sb.append(" World"); // 允许修改对象内容
     // sb = new StringBuilder("Java"); // 不允许重新赋值
     ```

3. **常量提升性能：**
   - 使用 `final` 修饰的基本数据类型或字符串常量会被编译器优化为编译期常量，从而提升性能。