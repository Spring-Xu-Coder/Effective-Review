# 基础数据类型介绍

Java 的基础数据类型（Primitive Data Types）是语言中最基本的数据存储单元，它们直接存储在栈内存中，具有高效访问和操作的特点。Java 提供了 **8 种基础数据类型**，分为以下四类：

---

### 1. 整数类型
用于存储整数值，包括正数、负数和零。

| 类型    | 大小（字节） | 取值范围                          | 默认值  | 示例           |
|---------|--------------|-----------------------------------|---------|----------------|
| `byte`  | 1            | -128 到 127                       | 0       | `byte b = 100;`|
| `short` | 2            | -32,768 到 32,767                 | 0       | `short s = 500;`|
| `int`   | 4            | -2^31 到 2^31-1（约 -21 亿到 21 亿）| 0       | `int i = 100000;`|
| `long`  | 8            | -2^63 到 2^63-1                   | 0L      | `long l = 10000000000L;`|

**注意**：
- `byte` 为什么没有128
    - 在计算机中，整数通常以 二进制补码 的形式存储。
    - 对于一个 8 位的 byte 类型：
        - 最高位（第 8 位）是符号位：0 表示正数，1 表示负数。
        - 剩下的 7 位用于表示数值。
- `long` 类型的值需要在数字后加 `L` 或 `l` 作为后缀。
- `int` 是最常用的整数类型。

---

### 2. 浮点类型
用于存储小数或科学计数法表示的数值。

| 类型     | 大小（字节） | 精度范围                          | 默认值  | 示例               |
|----------|--------------|-----------------------------------|---------|--------------------|
| `float`  | 4            | 约 ±3.4e-38 到 ±3.4e38            | 0.0f    | `float f = 3.14f;` |
| `double` | 8            | 约 ±1.7e-308 到 ±1.7e308          | 0.0d    | `double d = 3.14159;`|

**注意**：
- `float` 类型的值需要在数字后加 `F` 或 `f` 作为后缀。
- `double` 是默认的浮点类型，精度更高。

---

### 3. 字符类型
用于存储单个字符。

| 类型     | 大小（字节） | 取值范围                          | 默认值  | 示例               |
|----------|--------------|-----------------------------------|---------|--------------------|
| `char`   | 2            | 0 到 65,535（Unicode 字符）       | '\u0000'| `char c = 'A';`    |

**注意**：
- `char` 使用单引号 `''` 表示字符。
- 可以存储 Unicode 字符，例如 `char c = '\u0041';` 表示字符 `A`。

---

### 4. 布尔类型
用于表示逻辑值，只有两种取值。

| 类型      | 大小（字节） | 取值范围       | 默认值   | 示例               |
|-----------|--------------|----------------|----------|--------------------|
| `boolean` | 1（未严格定义）| `true` 或 `false` | `false`  | `boolean flag = true;`|

**注意**：
- `boolean` 类型不能与其他类型（如 `int`）相互转换。
- 在 JVM 中，`boolean` 的实际存储大小未严格定义，通常用 1 位表示。

---

### 5. 基础数据类型的特点
1. **高效性**：基础数据类型直接存储在栈内存中，访问速度快。
2. **不可变性**：基础数据类型的值是固定的，不能扩展或修改。
3. **默认值**：如果未显式赋值，基础数据类型会有默认值（如 `int` 默认为 `0`）。
4. **无方法**：基础数据类型不是对象，因此没有方法或属性。

---

### 6. 基础数据类型与包装类
Java 为每种基础数据类型提供了对应的包装类（Wrapper Class），用于将基础数据类型转换为对象，以便在集合等场景中使用。

| 基础数据类型 | 包装类       |
|--------------|--------------|
| `byte`       | `Byte`       |
| `short`      | `Short`      |
| `int`        | `Integer`    |
| `long`       | `Long`       |
| `float`      | `Float`      |
| `double`     | `Double`     |
| `char`       | `Character`  |
| `boolean`    | `Boolean`    |

**示例**：
```java
int num = 10;
Integer numObj = Integer.valueOf(num); // 装箱
int num2 = numObj.intValue();         // 拆箱
```

---

### 7. 自动装箱与拆箱
Java 5 引入了自动装箱（Autoboxing）和拆箱（Unboxing）机制，简化了基础数据类型与包装类之间的转换。

**示例**：
```java
Integer numObj = 10;  // 自动装箱
int num = numObj;     // 自动拆箱
```

#### **7.1. 自动装箱（Autoboxing）**
**定义**：将基本数据类型自动转换为其对应的包装类对象。

##### **原理**
- Java 编译器会在编译时将基本数据类型隐式地转换为包装类的构造函数调用。
- 例如：
  - `Integer i = 10;` 等价于 `Integer i = Integer.valueOf(10);`

##### **示例**
```java
int a = 10;
Integer b = a; // 自动装箱：等价于 Integer b = Integer.valueOf(a);
```

##### **底层实现**
- 装箱操作通过包装类的静态方法 `valueOf()` 实现。
- 例如，对于 `Integer` 类型，编译器会调用 `Integer.valueOf(int)` 方法。
- `valueOf()` 方法会根据值缓存机制决定是否返回已有的对象或创建新对象。

##### **值缓存机制**
- 对于 `Integer` 类型，值范围 `-128` 到 `127` 的对象会被缓存。
- 示例：
  ```java
  Integer x = 100; // 缓存中的对象
  Integer y = 100;
  System.out.println(x == y); // true，因为引用相同

  Integer z = 150; // 超出缓存范围
  Integer w = 150;
  System.out.println(z == w); // false，因为是不同对象
  ```

---

#### **7.2. 自动拆箱（Unboxing）**
**定义**：将包装类对象自动转换为对应的基本数据类型。

##### **原理**
- Java 编译器会在编译时将包装类对象隐式地转换为调用其 `xxxValue()` 方法。
- 例如：
  - `int c = b;` 等价于 `int c = b.intValue();`

##### **示例**
```java
Integer d = 20;
int e = d; // 自动拆箱：等价于 int e = d.intValue();
```

##### **底层实现**
- 拆箱操作通过包装类的 `xxxValue()` 方法实现。
- 例如，对于 `Integer` 类型，编译器会调用 `intValue()` 方法。

---

#### **7.3. 自动装箱与拆箱的应用场景**
##### **常见场景**
1. **集合框架**：
   - 集合类（如 `ArrayList`、`HashMap`）只能存储对象，不能存储基本数据类型。
   - 使用自动装箱可以将基本类型自动转换为包装类对象。
   ```java
   List<Integer> list = new ArrayList<>();
   list.add(10); // 自动装箱：等价于 list.add(Integer.valueOf(10));
   int value = list.get(0); // 自动拆箱：等价于 int value = list.get(0).intValue();
   ```

2. **方法参数传递**：
   - 如果方法参数需要包装类对象，而传入的是基本类型，则会发生自动装箱。
   ```java
   public void print(Integer num) {
       System.out.println(num);
   }

   print(5); // 自动装箱：等价于 print(Integer.valueOf(5));
   ```

3. **运算表达式**：
   - 在混合使用基本类型和包装类对象时，可能发生自动拆箱。
   ```java
   Integer a = 10;
   Integer b = 20;
   int sum = a + b; // 自动拆箱：等价于 int sum = a.intValue() + b.intValue();
   ```

---

#### **7.4. 注意事项**
虽然自动装箱和拆箱简化了代码，但也可能引发一些问题：

##### **性能问题**
- 自动装箱和拆箱涉及对象的创建或方法调用，可能会带来额外的性能开销。
- 尤其是在循环中频繁使用时，可能导致性能下降。

##### **空指针异常**
- 如果包装类对象为 `null`，拆箱时会抛出 `NullPointerException`。
```java
Integer x = null;
int y = x; // 抛出 NullPointerException
```

##### **== 运算符的陷阱**
- 对于包装类对象，`==` 比较的是引用，而不是值。
- 示例：
  ```java
  Integer a = 100;
  Integer b = 100;
  System.out.println(a == b); // true（值在缓存范围内）

  Integer c = 200;
  Integer d = 200;
  System.out.println(c == d); // false（超出缓存范围）
  ```

#### **7.5. 总结**
- **自动装箱**：基本类型 → 包装类对象（通过 `valueOf()` 方法）。
- **自动拆箱**：包装类对象 → 基本类型（通过 `xxxValue()` 方法）。
- **优点**：简化代码，减少手动转换的工作量。
- **缺点**：可能导致性能问题或空指针异常，需谨慎使用。
---