## JVM 内存模型概要

Java 虚拟机（JVM）内存模型定义了 Java 程序在运行时的内存分配和管理方式。JVM 内存模型是 Java 程序执行的基础，理解它对于编写高效、稳定的 Java 程序至关重要。以下是 JVM 内存模型的概要。

---

### 1. **JVM 内存区域划分**

- JDK 1.8 以前
![内存模型](/Java/资源/5.1JVM%20内存架构-旧模型.png)

- JDK 1.8 以后
![内存模型](/Java/资源/5.1JVM%20内存架构-旧模型.png)



JVM 内存主要分为以下几个区域：

#### 1.1 方法区（Method Area）
- **作用**：存储类的元数据（如类名、方法信息、字段信息）、常量池、静态变量等。
- **特点**：
  - 所有线程共享。
  - 在 JVM 启动时创建。
  - 如果方法区无法满足内存分配需求，会抛出 `OutOfMemoryError`。

#### 1.2 堆（Heap）
- **作用**：存储对象实例和数组。
- **特点**：
  - 所有线程共享。
  - 是垃圾回收（GC）的主要区域。
  - 堆可以分为新生代（Young Generation）和老年代（Old Generation）。
  - 如果堆无法满足内存分配需求，会抛出 `OutOfMemoryError`。

#### 1.3 栈（Stack）
- **作用**：存储局部变量、方法调用栈帧、操作数栈等。
- **特点**：
  - 每个线程独享一个栈。
  - 栈帧用于存储方法的局部变量、操作数栈、动态链接和方法返回地址。
  - 如果栈深度超过限制，会抛出 `StackOverflowError`。
  - 如果栈无法扩展，会抛出 `OutOfMemoryError`。

#### 1.4 本地方法栈（Native Method Stack）
- **作用**：为 JVM 调用本地方法（Native Method）服务。
- **特点**：
  - 每个线程独享一个本地方法栈。
  - 与栈类似，但用于本地方法调用。

#### 1.5 程序计数器（Program Counter Register）
- **作用**：记录当前线程执行的字节码指令地址。
- **特点**：
  - 每个线程独享一个程序计数器。
  - 如果执行的是本地方法，程序计数器的值为 `undefined`。

---

### 2. **堆内存的详细划分**

堆内存是 JVM 中最重要的内存区域，主要分为以下几个部分：

#### 2.1 新生代（Young Generation）
- **作用**：存放新创建的对象。
- **特点**：
  - 分为 Eden 区、Survivor 区（From 和 To）。
  - 大多数对象在 Eden 区创建。
  - 经过一次 Minor GC 后，存活的对象会被移动到 Survivor 区。
  - 经过多次 GC 后仍然存活的对象会被移动到老年代。

#### 2.2 老年代（Old Generation）
- **作用**：存放长期存活的对象。
- **特点**：
  - 对象从新生代晋升到老年代。
  - 老年代的 GC 称为 Major GC 或 Full GC，通常比 Minor GC 耗时更长。

#### 2.3 元空间（Metaspace，Java 8+）
- **作用**：替代永久代（PermGen），存储类的元数据。
- **特点**：
  - 元空间使用本地内存（Native Memory），而不是 JVM 堆内存。
  - 默认情况下，元空间的大小仅受本地内存限制。

---

### 3. **垃圾回收（Garbage Collection, GC）**

#### 3.1 垃圾回收的作用
- 自动管理堆内存，回收不再使用的对象。
- 防止内存泄漏，提高内存利用率。

#### 3.2 垃圾回收算法
- **标记-清除（Mark-Sweep）**：标记存活对象，清除未标记对象。
- **复制（Copying）**：将存活对象复制到另一个区域，清空当前区域。
- **标记-整理（Mark-Compact）**：标记存活对象，整理内存空间。
- **分代收集（Generational Collection）**：根据对象存活时间将堆分为新生代和老年代，分别采用不同的回收算法。

#### 3.3 常见的垃圾回收器
- **Serial GC**：单线程垃圾回收器，适用于小型应用。
- **Parallel GC**：多线程垃圾回收器，适用于多核 CPU。
- **CMS（Concurrent Mark-Sweep）**：以最短停顿时间为目标的垃圾回收器。
- **G1（Garbage-First）**：面向服务端应用的垃圾回收器，兼顾吞吐量和停顿时间。
- **ZGC（Z Garbage Collector）**：低延迟垃圾回收器，适用于大内存应用。

---

### 4. **JVM 内存模型与多线程**

#### 4.1 线程私有内存
- 每个线程独享栈、本地方法栈和程序计数器。
- 线程私有内存不需要同步，访问速度快。

#### 4.2 线程共享内存
- 方法区和堆是所有线程共享的内存区域。
- 访问共享内存需要同步机制（如锁、`volatile` 关键字）。

#### 4.3 内存可见性
- 由于线程私有内存和共享内存的存在，多线程环境下可能出现内存可见性问题。
- 使用 `volatile` 关键字或同步机制可以保证内存可见性。

---

### 5. **JVM 内存参数**

#### 5.1 常用 JVM 参数
- `-Xms`：设置堆的初始大小。
- `-Xmx`：设置堆的最大大小。
- `-Xmn`：设置新生代的大小。
- `-XX:MetaspaceSize`：设置元空间的初始大小。
- `-XX:MaxMetaspaceSize`：设置元空间的最大大小。
- `-Xss`：设置每个线程的栈大小。

**示例**：
```bash
java -Xms512m -Xmx1024m -Xmn256m -Xss1m -jar myapp.jar
```

---

### 6. **总结**

- JVM 内存模型包括方法区、堆、栈、本地方法栈和程序计数器。
- 堆内存分为新生代和老年代，是垃圾回收的主要区域。
- 垃圾回收算法和垃圾回收器对程序性能有重要影响。
- 多线程环境下需要注意内存可见性问题。
- 通过合理设置 JVM 参数，可以优化程序的内存使用和性能。

理解 JVM 内存模型是编写高效、稳定 Java 程序的基础，也是排查内存相关问题的关键。