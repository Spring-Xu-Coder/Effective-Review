# Java 垃圾回收（GC）概要

Java 垃圾回收（Garbage Collection, GC）是 JVM 自动管理内存的核心机制，负责回收不再使用的对象以释放内存，避免内存泄漏。以下是其核心要点：

---

## **1. GC 的核心原理**
1. **对象存活判定**：
   - **引用计数法**（Java 未采用）：记录对象被引用的次数，归零时回收。
   - **可达性分析**（Java 实际使用）：从 GC Roots（如栈帧局部变量、静态变量等）出发，不可达的对象标记为可回收。

2. **垃圾回收算法**：
   - **标记-清除（Mark-Sweep）**：标记存活对象，清除未标记对象（产生内存碎片）。
   - **复制（Copying）**：将存活对象复制到新内存区域，清空旧区域（无碎片，适合新生代）。
   - **标记-整理（Mark-Compact）**：标记存活对象后整理内存，消除碎片（适合老年代）。
   - **分代收集（Generational）**：将堆分为新生代（Young）和老年代（Old），采用不同算法（主流实现）。

---

## **2. 堆内存分代模型**
1. **新生代（Young Generation）**：
   - **特点**：存放新创建的对象，生命周期短。
   - **区域划分**：
     - **Eden 区**：对象初次分配区域。
     - **Survivor 区（From/To）**：存放经过 Minor GC 后存活的对象。
   - **GC 类型**：**Minor GC**（快速回收，使用复制算法）。

2. **老年代（Old Generation）**：
   - **特点**：存放长期存活的对象（如多次 Minor GC 后仍存活的对象）。
   - **GC 类型**：**Major GC/Full GC**（耗时较长，使用标记-清除或标记-整理算法）。

3. **永久代/方法区（元空间（Metaspace，Java 8+））**：
   - 替代永久代（PermGen），存储类元数据（如类名、方法信息），使用本地内存（Native Memory）。

---

## **3. 常见垃圾收集器**
| 收集器                | 特点                                                                 | 适用场景                     |
|-----------------------|----------------------------------------------------------------------|------------------------------|
| **Serial**            | 单线程，简单高效，需暂停所有用户线程（Stop-The-World）。              | 客户端小应用，低资源环境。   |
| **Parallel/Throughput** | 多线程，高吞吐量，以牺牲延迟为代价优化吞吐量。                        | 后台计算型应用。             |
| **CMS**               | 并发标记清除，减少停顿时间，但内存碎片多，已逐步淘汰。                | 响应优先的 Web 服务。        |
| **G1（Garbage-First）** | 分区域（Region）管理，兼顾吞吐量和延迟，可预测停顿时间（默认 JDK 9+）。| 大内存、低延迟应用。         |
| **ZGC**               | 低延迟（<10ms），支持 TB 级堆内存，通过染色指针和读屏障实现。         | 超大规模实时系统（JDK 15+）。|
| **Shenandoah**        | 类似 ZGC，与用户线程并发执行，低延迟。                                | 高响应需求场景（JDK 12+）。  |

---

## **4. GC 调优与监控**
1. **关键 JVM 参数**：
   - `-Xms` / `-Xmx`：堆初始/最大内存。
   - `-XX:NewRatio`：老年代与新生代的比例。
   - `-XX:SurvivorRatio`：Eden 区与 Survivor 区的比例。
   - `-XX:+UseG1GC`：启用 G1 收集器。

2. **监控工具**：
   - **jstat**：查看堆内存和 GC 统计（如 `jstat -gc <pid> 1000`）。
   - **VisualVM** / **JConsole**：图形化监控堆内存和 GC 活动。
   - **GC 日志**：通过 `-Xloggc:<file>` 和 `-XX:+PrintGCDetails` 生成日志分析。

3. **调优目标**：
   - 减少 Full GC 频率和停顿时间。
   - 避免内存泄漏（如未关闭的资源、静态集合缓存）。
   - 合理分配堆内存大小，避免频繁扩容。

---

## **5. 常见 GC 问题与解决**
1. **频繁 Full GC**：
   - **原因**：老年代空间不足（内存泄漏或 Survivor 区过小）。
   - **解决**：检查大对象分配，优化 Survivor 区比例，升级收集器（如 G1/ZGC）。

2. **长时间 Stop-The-World**：
   - **原因**：堆内存过大或收集器配置不当。
   - **解决**：使用低延迟收集器（如 G1/ZGC），调整最大停顿时间参数（如 `-XX:MaxGCPauseMillis`）。

3. **内存泄漏**：
   - **现象**：堆内存持续增长，Full GC 后无明显释放。
   - **工具**：使用 **MAT（Memory Analyzer）** 分析堆转储文件（Heap Dump）。

---

## **6. 总结**
- **GC 目标**：自动管理内存，平衡吞吐量（Throughput）、延迟（Latency）和内存占用。
- **分代模型**：新生代（Minor GC）与老年代（Full GC）分工明确。
- **收集器选择**：根据应用场景（吞吐量优先 or 低延迟优先）合理选择。
- **调优核心**：监控 GC 日志，优化堆内存分配，避免代码层面的内存泄漏。